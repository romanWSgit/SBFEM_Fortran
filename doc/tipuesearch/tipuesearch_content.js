var tipuesearch = {"pages":[{"title":" SBFEM ","text":"SBFEM Developer Info Roman Wallner- Silberhuber","tags":"home","loc":"index.html"},{"title":"superElement – SBFEM ","text":"type, public :: superElement Components Type Visibility Attributes Name Initial integer, public :: polygon_order integer, public :: number_of_elements integer, public :: number_of_nodes integer, public :: dof character(len=:), public, allocatable :: shape_function_type real(kind=real64), public, allocatable :: nodes (:,:) real(kind=real64), public, allocatable :: nodes_C (:,:) real(kind=real64), public, allocatable :: elements_M (:,:) real(kind=real64), public, allocatable :: elements_MC (:,:) Constructor public        interface superElement private  function superElement_json_constructor(path) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value type( superElement ) Type-Bound Procedures procedure, public, pass(this) :: print_super_element private  subroutine print_super_element(this) Arguments Type Intent Optional Attributes Name class( superElement ), intent(in) :: this","tags":"","loc":"type/superelement.html"},{"title":"chdir – SBFEM","text":"public  subroutine chdir(path, err) Uses iso_c_binding Arguments Type Intent Optional Attributes Name character(len=*) :: path integer, intent(out), optional :: err","tags":"","loc":"proc/chdir.html"},{"title":"c_chdir – SBFEM","text":"interface public  function c_chdir(path) bind(C,name=\"chdir\") Arguments Type Intent Optional Attributes Name character(kind=c_char, len=1) :: path (*) Return Value integer","tags":"","loc":"interface/c_chdir.html"},{"title":"superElement – SBFEM","text":"public interface superElement Module Procedures private  function superElement_json_constructor(path) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value type( superElement )","tags":"","loc":"interface/superelement.html"},{"title":"lagrange – SBFEM","text":"public  function lagrange(x, i, xm) result(y) Evaluates the i-th Lagrange polynomial at x based on grid data xm Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x integer, intent(in) :: i real(kind=real64), intent(in) :: xm (:) Return Value real(kind=real64)","tags":"","loc":"proc/lagrange.html"},{"title":"lagrange_diff – SBFEM","text":"public  function lagrange_diff(x, i, xm) result(y) Evaluates the i-th Lagrange polynomial at x based on grid data xm Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x integer, intent(in) :: i real(kind=real64), intent(in) :: xm (:) Return Value real(kind=real64)","tags":"","loc":"proc/lagrange_diff.html"},{"title":"point_table – SBFEM","text":"public  function point_table(poly_ord) result(p_table) Arguments Type Intent Optional Attributes Name integer(kind=cint), intent(in) :: poly_ord Return Value real(kind=cdp), allocatable, (:)","tags":"","loc":"proc/point_table.html"},{"title":"read_matrix_from_json – SBFEM","text":"public  function read_matrix_from_json(object, path) result(imat) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: object character(len=*), intent(in) :: path Return Value real(kind=cdp), allocatable, (:,:)","tags":"","loc":"proc/read_matrix_from_json.html"},{"title":"append_int – SBFEM","text":"public  subroutine append_int(vec, val) \\brief Appends val in vec if not already present\n \\date 05 2020 Arguments Type Intent Optional Attributes Name integer(kind=cint), intent(inout), allocatable :: vec (:) integer(kind=cint), intent(in) :: val","tags":"","loc":"proc/append_int.html"},{"title":"append_real64 – SBFEM","text":"public  subroutine append_real64(vec, val) \\brief Appends val in vec if not already present\n \\date 05 2020 Arguments Type Intent Optional Attributes Name real(kind=cdp), intent(inout), allocatable :: vec (:) real(kind=cdp), intent(in) :: val","tags":"","loc":"proc/append_real64.html"},{"title":"print_matrix – SBFEM","text":"public  subroutine print_matrix(a, m, n) Our amazing subroutine to say hello (FORD) Who to say hello to Arguments Type Intent Optional Attributes Name real(kind=cdp), intent(in) :: a (m,n) integer(kind=cint), intent(in) :: m integer(kind=cint), intent(in) :: n","tags":"","loc":"proc/print_matrix.html"},{"title":"print_column_vector – SBFEM","text":"public  subroutine print_column_vector(a, m) Arguments Type Intent Optional Attributes Name real(kind=cdp), intent(in) :: a (m) integer(kind=cint), intent(in) :: m","tags":"","loc":"proc/print_column_vector.html"},{"title":"read_data_from_json – SBFEM","text":"public  subroutine read_data_from_json(polygon_order, number_of_elements, dofs, number_of_nodes, shape_fct_type, path) Arguments Type Intent Optional Attributes Name integer(kind=cint), intent(inout) :: polygon_order integer(kind=cint), intent(inout) :: number_of_elements integer(kind=cint), intent(inout) :: dofs integer(kind=cint), intent(inout) :: number_of_nodes character(len=60), intent(out) :: shape_fct_type character(len=*), intent(in) :: path","tags":"","loc":"proc/read_data_from_json.html"},{"title":"check_working_environment – SBFEM","text":"public  subroutine check_working_environment() Arguments None","tags":"","loc":"proc/check_working_environment.html"},{"title":"plot_shape_functions – SBFEM","text":"public  subroutine plot_shape_functions(poly_ord) Arguments Type Intent Optional Attributes Name integer, intent(in) :: poly_ord","tags":"","loc":"proc/plot_shape_functions.html"},{"title":"plot_superElement – SBFEM","text":"public  subroutine plot_superElement(sE) Arguments Type Intent Optional Attributes Name type( superElement ), intent(in) :: sE","tags":"","loc":"proc/plot_superelement.html"},{"title":"n_vec_f – SBFEM","text":"public  function n_vec_f(eta, poly_ord, deriv) result(n_vec) Computes the shape function vector or its derivative for a \ngiven polynomial order and evaluation point. Arguments Type Intent Optional Attributes Name real(kind=cdp), intent(in) :: eta The natural coordinate (real number) at which the shape function \nor its derivative is evaluated. integer(kind=cint), intent(in) :: poly_ord The natural coordinate (real number) at which the shape function logical, intent(in) :: deriv A logical type which determines whether the shape function or its\nderivative is computed. If deriv is true, the derivative is computed. Return Value real(kind=cdp), (poly_ord+1) The shape function vector or its derivative.","tags":"","loc":"proc/n_vec_f.html"},{"title":"n_mat_f – SBFEM","text":"public  function n_mat_f(eta, poly_ord, deriv) result(n_mat) create the shape function Vector and Matrix N Arguments Type Intent Optional Attributes Name real(kind=cdp), intent(in) :: eta integer(kind=cint), intent(in) :: poly_ord logical, intent(in) :: deriv Return Value real(kind=cdp), (2,(poly_ord+1)*2)","tags":"","loc":"proc/n_mat_f.html"},{"title":"r_hat – SBFEM","text":"public  function r_hat(xi, eta, poly_ord, coord_vec, centre) result(r_vec) create the shape function Vector and Matrix N Arguments Type Intent Optional Attributes Name real(kind=cdp), intent(in) :: xi real(kind=cdp), intent(in) :: eta integer(kind=cint), intent(in) :: poly_ord real(kind=cdp), intent(in) :: coord_vec (:) real(kind=cdp), intent(in), optional :: centre (2) Return Value real(kind=cdp), (2)","tags":"","loc":"proc/r_hat.html"},{"title":"r – SBFEM","text":"public  function r(eta, poly_ord, coord_vec, centre) result(r_vec) create the shape function Vector and Matrix N Arguments Type Intent Optional Attributes Name real(kind=cdp), intent(in) :: eta integer(kind=cint), intent(in) :: poly_ord real(kind=cdp), intent(in) :: coord_vec (:) real(kind=cdp), intent(in), optional :: centre (2) Return Value real(kind=cdp), (2)","tags":"","loc":"proc/r.html"},{"title":"j_mat – SBFEM","text":"public  function j_mat(eta, coord_vec, poly_ord, shape_function_type, centre) result(j_matrix) Arguments Type Intent Optional Attributes Name real(kind=cdp), intent(in) :: eta real(kind=cdp), intent(in), dimension(2) :: coord_vec integer(kind=cint), intent(in) :: poly_ord character(len=:), intent(in), allocatable :: shape_function_type real(kind=cdp), intent(in), dimension(2) :: centre Return Value real(kind=cdp), dimension(2,2)","tags":"","loc":"proc/j_mat.html"},{"title":"j_hat_mat – SBFEM","text":"public  function j_hat_mat(xi, eta, coord_vec, poly_ord, shape_function_type, centre) result(j_hat_matrix) Arguments Type Intent Optional Attributes Name real(kind=cdp), intent(in) :: xi real(kind=cdp), intent(in) :: eta real(kind=cdp), intent(in), dimension(2) :: coord_vec integer(kind=cint), intent(in) :: poly_ord character(len=:), intent(in), allocatable :: shape_function_type real(kind=cdp), intent(in), dimension(2) :: centre Return Value real(kind=cdp), dimension(2,2)","tags":"","loc":"proc/j_hat_mat.html"},{"title":"chdir_module – SBFEM","text":"Interfaces interface public  function c_chdir(path) bind(C,name=\"chdir\") Arguments Type Intent Optional Attributes Name character(kind=c_char, len=1) :: path (*) Return Value integer Subroutines public  subroutine chdir (path, err) Arguments Type Intent Optional Attributes Name character(len=*) :: path integer, intent(out), optional :: err","tags":"","loc":"module/chdir_module.html"},{"title":"SbfemClass – SBFEM","text":"Uses helper_functions iso_fortran_env Interfaces public        interface superElement private  function superElement_json_constructor(path) result(res) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: path Return Value type( superElement ) Derived Types type, public :: superElement Components Type Visibility Attributes Name Initial integer, public :: polygon_order integer, public :: number_of_elements integer, public :: number_of_nodes integer, public :: dof character(len=:), public, allocatable :: shape_function_type real(kind=real64), public, allocatable :: nodes (:,:) real(kind=real64), public, allocatable :: nodes_C (:,:) real(kind=real64), public, allocatable :: elements_M (:,:) real(kind=real64), public, allocatable :: elements_MC (:,:) Constructor private\n\n                    \n                    function superElement_json_constructor (path) Type-Bound Procedures procedure, public, pass(this) :: print_super_element","tags":"","loc":"module/sbfemclass.html"},{"title":"math – SBFEM","text":"Uses iso_fortran_env Functions public  function lagrange (x, i, xm) result(y) Evaluates the i-th Lagrange polynomial at x based on grid data xm Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x integer, intent(in) :: i real(kind=real64), intent(in) :: xm (:) Return Value real(kind=real64) public  function lagrange_diff (x, i, xm) result(y) Evaluates the i-th Lagrange polynomial at x based on grid data xm Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x integer, intent(in) :: i real(kind=real64), intent(in) :: xm (:) Return Value real(kind=real64)","tags":"","loc":"module/math.html"},{"title":"helper_functions – SBFEM","text":"Uses json_module iso_c_binding Functions public  function point_table (poly_ord) result(p_table) Arguments Type Intent Optional Attributes Name integer(kind=cint), intent(in) :: poly_ord Return Value real(kind=cdp), allocatable, (:) public  function read_matrix_from_json (object, path) result(imat) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: object character(len=*), intent(in) :: path Return Value real(kind=cdp), allocatable, (:,:) Subroutines public  subroutine append_int (vec, val) \\brief Appends val in vec if not already present\n \\date 05 2020 Read more… Arguments Type Intent Optional Attributes Name integer(kind=cint), intent(inout), allocatable :: vec (:) integer(kind=cint), intent(in) :: val public  subroutine append_real64 (vec, val) \\brief Appends val in vec if not already present\n \\date 05 2020 Read more… Arguments Type Intent Optional Attributes Name real(kind=cdp), intent(inout), allocatable :: vec (:) real(kind=cdp), intent(in) :: val public  subroutine print_matrix (a, m, n) Our amazing subroutine to say hello (FORD) Read more… Arguments Type Intent Optional Attributes Name real(kind=cdp), intent(in) :: a (m,n) integer(kind=cint), intent(in) :: m integer(kind=cint), intent(in) :: n public  subroutine print_column_vector (a, m) Arguments Type Intent Optional Attributes Name real(kind=cdp), intent(in) :: a (m) integer(kind=cint), intent(in) :: m public  subroutine read_data_from_json (polygon_order, number_of_elements, dofs, number_of_nodes, shape_fct_type, path) Arguments Type Intent Optional Attributes Name integer(kind=cint), intent(inout) :: polygon_order integer(kind=cint), intent(inout) :: number_of_elements integer(kind=cint), intent(inout) :: dofs integer(kind=cint), intent(inout) :: number_of_nodes character(len=60), intent(out) :: shape_fct_type character(len=*), intent(in) :: path public  subroutine check_working_environment () Arguments None","tags":"","loc":"module/helper_functions.html"},{"title":"plots – SBFEM","text":"Uses sbfem_functions iso_fortran_env helper_functions SbfemClass math functional Subroutines public  subroutine plot_shape_functions (poly_ord) Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: poly_ord public  subroutine plot_superElement (sE) Read more… Arguments Type Intent Optional Attributes Name type( superElement ), intent(in) :: sE","tags":"","loc":"module/plots.html"},{"title":"sbfem_functions – SBFEM","text":"Computes the shape function vector or its derivative for a \ngiven polynomial order and evaluation point. Uses functional helper_functions iso_c_binding math Functions public  function n_vec_f (eta, poly_ord, deriv) result(n_vec) Computes the shape function vector or its derivative for a \ngiven polynomial order and evaluation point. Arguments Type Intent Optional Attributes Name real(kind=cdp), intent(in) :: eta The natural coordinate (real number) at which the shape function \nor its derivative is evaluated. integer(kind=cint), intent(in) :: poly_ord The natural coordinate (real number) at which the shape function logical, intent(in) :: deriv A logical type which determines whether the shape function or its\nderivative is computed. If deriv is true, the derivative is computed. Return Value real(kind=cdp), (poly_ord+1) The shape function vector or its derivative. public  function n_mat_f (eta, poly_ord, deriv) result(n_mat) create the shape function Vector and Matrix N Arguments Type Intent Optional Attributes Name real(kind=cdp), intent(in) :: eta integer(kind=cint), intent(in) :: poly_ord logical, intent(in) :: deriv Return Value real(kind=cdp), (2,(poly_ord+1)*2) public  function r_hat (xi, eta, poly_ord, coord_vec, centre) result(r_vec) create the shape function Vector and Matrix N Arguments Type Intent Optional Attributes Name real(kind=cdp), intent(in) :: xi real(kind=cdp), intent(in) :: eta integer(kind=cint), intent(in) :: poly_ord real(kind=cdp), intent(in) :: coord_vec (:) real(kind=cdp), intent(in), optional :: centre (2) Return Value real(kind=cdp), (2) public  function r (eta, poly_ord, coord_vec, centre) result(r_vec) create the shape function Vector and Matrix N Arguments Type Intent Optional Attributes Name real(kind=cdp), intent(in) :: eta integer(kind=cint), intent(in) :: poly_ord real(kind=cdp), intent(in) :: coord_vec (:) real(kind=cdp), intent(in), optional :: centre (2) Return Value real(kind=cdp), (2) public  function j_mat (eta, coord_vec, poly_ord, shape_function_type, centre) result(j_matrix) Arguments Type Intent Optional Attributes Name real(kind=cdp), intent(in) :: eta real(kind=cdp), intent(in), dimension(2) :: coord_vec integer(kind=cint), intent(in) :: poly_ord character(len=:), intent(in), allocatable :: shape_function_type real(kind=cdp), intent(in), dimension(2) :: centre Return Value real(kind=cdp), dimension(2,2) public  function j_hat_mat (xi, eta, coord_vec, poly_ord, shape_function_type, centre) result(j_hat_matrix) Arguments Type Intent Optional Attributes Name real(kind=cdp), intent(in) :: xi real(kind=cdp), intent(in) :: eta real(kind=cdp), intent(in), dimension(2) :: coord_vec integer(kind=cint), intent(in) :: poly_ord character(len=:), intent(in), allocatable :: shape_function_type real(kind=cdp), intent(in), dimension(2) :: centre Return Value real(kind=cdp), dimension(2,2)","tags":"","loc":"module/sbfem_functions.html"},{"title":"example – SBFEM","text":"Uses json_module iso_fortran_env Variables Type Attributes Name Initial real(kind=rk), allocatable :: nodes (:,:) type(json_file) :: json logical :: is_found","tags":"","loc":"program/example.html"},{"title":"sbfem – SBFEM","text":"Uses sbfem_functions helper_functions iso_c_binding SbfemClass functional plots This is an simple program Variables Type Attributes Name Initial integer(kind=cint) :: poly_ord = 1 type( superElement ) :: sE character(len=50) :: path character(len=20) :: object1 integer(kind=cint), allocatable :: shape_elementsM (:) integer(kind=cint), allocatable :: shape_nodes (:)","tags":"","loc":"program/sbfem.html"},{"title":"chdir_module.f90 – SBFEM","text":"Source Code module chdir_module implicit none interface integer function c_chdir ( path ) bind ( C , name = \"chdir\" ) use iso_c_binding character ( kind = c_char ) :: path ( * ) end function end interface contains subroutine chdir ( path , err ) use iso_c_binding character ( * ) :: path integer , optional , intent ( out ) :: err integer :: loc_err loc_err = c_chdir ( path // c_null_char ) if ( present ( err )) err = loc_err end subroutine end module chdir_module","tags":"","loc":"sourcefile/chdir_module.f90.html"},{"title":"SbfemClass.f90 – SBFEM","text":"Source Code module SbfemClass use iso_fortran_env use helper_functions , only : print_matrix , print_column_vector , & read_matrix_from_json , check_working_environment , & read_data_from_json implicit none private ! everything is hidden type , public :: superElement integer :: polygon_order integer :: number_of_elements integer :: number_of_nodes integer :: dof character ( len = :), allocatable :: shape_function_type real ( real64 ), allocatable :: nodes (:,:) real ( real64 ), allocatable :: nodes_C (:,:) real ( real64 ), allocatable :: elements_M (:,:) real ( real64 ), allocatable :: elements_MC (:,:) contains procedure , pass ( this ) :: print_super_element ! procedure :: read_super_element_from_json => read_sE_from_json !final :: destructor end type superElement interface superElement module procedure :: superElement_json_constructor end interface superElement contains type ( superElement ) function superElement_json_constructor ( path ) result ( res ) Character ( * ), intent ( in ) :: path call read_data_from_json ( res % polygon_order , & res % number_of_elements , res % dof , res % number_of_nodes , res % shape_function_type , & path ) res % nodes = read_matrix_from_json ( \"nodes\" , path ) res % nodes_C = read_matrix_from_json ( \"nodesC\" , path ) res % elements_M = read_matrix_from_json ( \"elementsM\" , path ) res % elements_MC = read_matrix_from_json ( \"elementsMC\" , path ) end function superElement_json_constructor ! function Constructor() Result(superElement) !     type(superElement) :: sE !     !initialize variables directly !     sE%x=... !     ! or through method calls !     call Timer%setTime(now) ! end function Constructor ! subroutine destructor(this) !     class(superElement) :: this !     ! Do whatever needs doing in the destructor ! end subroutine destructor subroutine print_super_element ( this ) class ( superElement ), intent ( in ) :: this print * , \"sE: Polygon Order: \" , this % polygon_order print * , \"sE: Number of Elements: \" , this % number_of_elements print * , \"sE: Shape Function Type: \" , this % shape_function_type end subroutine print_super_element ! subroutine read_sE_from_json(this) !     class(superElement), intent(in) ::  this ! end subroutine end module SbfemClass","tags":"","loc":"sourcefile/sbfemclass.f90.html"},{"title":"math.f90 – SBFEM","text":"Source Code module math use iso_fortran_env ! use funtional ! use helper_functions, only: append_real64 implicit none private public :: lagrange , lagrange_diff contains real ( real64 ) function lagrange ( x , i , xm ) result ( y ) !! Evaluates the i-th Lagrange polynomial at x based on grid data xm real ( real64 ), intent ( in ) :: x integer , intent ( in ) :: i real ( real64 ), intent ( in ) :: xm (:) integer :: xm_size integer :: j integer :: n xm_size = size ( xm ) n = xm_size y = 1.0 do j = 1 , n if ( i /= j ) then y = y * (( x - xm ( j ) ) / ( xm ( i ) - xm ( j ) )) end if end do end function lagrange real ( real64 ) function lagrange_diff ( x , i , xm ) result ( y ) !! Evaluates the i-th Lagrange polynomial at x based on grid data xm real ( real64 ), intent ( in ) :: x integer , intent ( in ) :: i real ( real64 ), intent ( in ) :: xm (:) real ( real64 ) :: k integer :: xm_size integer :: m , l integer :: n xm_size = size ( xm ) n = xm_size y = 0.0 k = 0.0 do l = 1 , n if ( l /= i ) then k = 1 / ( xm ( i ) - xm ( l )) do m = 1 , n if (( m /= i ) . and . ( m /= l )) then k = k * ( x - xm ( m )) / ( xm ( i ) - xm ( m )) end if end do y = y + k end if end do end function lagrange_diff end module math","tags":"","loc":"sourcefile/math.f90.html"},{"title":"example.f90 – SBFEM","text":"Source Code program example use iso_fortran_env use :: json_module , rk => json_rk implicit none !real(real64), allocatable  :: nodes(:,:), elementsM(:,:) real ( kind = rk ), allocatable :: nodes (:,:) type ( json_file ) :: json logical :: is_found ! Initialise the json_file object. call json % initialize () ! Load the file. call json % load_file ( '/Users/roman_w_s/Desktop/SBFEM_DATA/rect_1.json' ); if ( json % failed ()) stop ! Read in the data. json_block : block !call json%get(\"t0\", t0, is_found); if (.not. is_found) exit json_block call json % get ( \"nodes\" , nodes , is_found ); if (. not . is_found ) exit json_block !call json%get(\"elementsM\", elementsM, is_found); if (.not. is_found) exit json_block end block json_block print * , nodes ! Output values. if ( is_found ) then print * , nodes ( 1 ) ! \t\tprint *, elementsM end if ! Clean up. call json % destroy () end program example","tags":"","loc":"sourcefile/example.f90.html"},{"title":"sbfem.f90 – SBFEM","text":"Source Code program sbfem !! This is an simple program use , intrinsic :: iso_c_binding , only : cdp => c_double , cint => c_int use functional , only : arange use plots , only : plot_shape_functions , plot_superElement use helper_functions , only : print_matrix , print_column_vector , & read_matrix_from_json , check_working_environment , & read_data_from_json use sbfem_functions , only : n_vec_f , n_mat_f , r_hat , r , j_hat_mat , j_mat !use math, only: lagrange, lagrange_diff use SbfemClass implicit none integer ( cint ) :: poly_ord = 1 type ( superElement ) :: sE Character ( len = 50 ) :: path Character ( len = 20 ) :: object1 integer ( cint ), allocatable :: shape_elementsM (:) integer ( cint ), allocatable :: shape_nodes (:) !real(cdp),allocatable :: elements_M(:,:) ! changing the working directory to a the bin call check_working_environment () path = '/Users/roman_w_s/Desktop/SBFEM_DATA/rect_1.json' !object1 = \"elementsM\" sE = superElement ( path ) ! read_data_from_json(sE%polygon_order, sE%number_of_elements, & !                     sE%dof, sE%number_of_nodes, path) ! call plot_shape_functions(poly_ord) ! call sE%print_super_element() print * , n_vec_f ( 0.5_cdp , poly_ord ,. true .) ! sE%nodes = read_matrix_from_json( \"nodes\", path) ! sE%nodes_C= read_matrix_from_json( \"nodesC\", path) ! sE%elements_M = read_matrix_from_json( \"elementsM\", path) ! sE%elements_MC = read_matrix_from_json( \"elementsMC\", path) print * , \"Dimensions of elementsM: \" , shape ( sE % elements_M ) print * , \"Dimensions of elementsM 1:\" , shape ( sE % elements_M ( 1 ,:)) shape_elementsM = shape ( sE % elements_M ) call print_matrix ( sE % elements_M , shape_elementsM ( 1 ), shape_elementsM ( 2 )) shape_nodes = shape ( sE % nodes ) call print_matrix ( sE % nodes , shape_nodes ( 1 ), shape_nodes ( 2 )) call print_column_vector ( sE % elements_M ( 1 ,:), 4 ) call print_column_vector ( r ( eta = - 1._cdp , & poly_ord = poly_ord , coord_vec = sE % elements_M ( 1 ,:) ), 2 ) call print_column_vector ( r_hat ( xi = 0.1_cdp , eta = - 1._cdp , & poly_ord = poly_ord , coord_vec = sE % elements_M ( 1 ,:) ), 2 ) ! call plot_superElement(sE) call sE % print_super_element () ! print*, j_hat_mat(xi, eta, coord_vec, poly_ord, shape_function_type, centre) print * , sE % elements_M ( 1 ,:) print * , j_hat_mat ( 0.1_cdp , 0.1_cdp , sE % elements_M ( 1 ,:), sE % polygon_order , sE % shape_function_type , [ 0.0_cdp , 0.0_cdp ]) print * , sE % shape_function_type end program sbfem","tags":"","loc":"sourcefile/sbfem.f90.html"},{"title":"helper_functions.f90 – SBFEM","text":"Source Code module helper_functions use json_module use , intrinsic :: iso_c_binding , only : cdp => c_double , cint => c_int ! use funtional implicit none private interface integer function c_chdir ( path ) bind ( C , name = \"chdir\" ) use iso_c_binding character ( kind = c_char ) :: path ( * ) end function end interface public :: append_int , append_real64 , point_table , print_matrix , & print_column_vector , read_matrix_from_json , & check_working_environment , read_data_from_json contains function point_table ( poly_ord ) result ( p_table ) integer ( cint ), intent ( in ) :: poly_ord real ( cdp ), allocatable :: p_table (:) real ( cdp ) :: res integer ( cint ) :: j allocate ( p_table ( poly_ord + 1 )) do j = 1 , ( poly_ord + 1 ) res = - 1._cdp + ( j - 1._cdp ) * 2._cdp / poly_ord p_table ( j ) = res end do end function point_table subroutine append_int ( vec , val ) !*********************************************************************** !> \\brief Appends val in vec if not already present !> \\date 05 2020 !*********************************************************************** integer ( cint ), allocatable , intent ( inout ) :: vec (:) integer ( cint ), intent ( in ) :: val vec = [ vec , val ] end subroutine append_int subroutine append_real64 ( vec , val ) !*********************************************************************** !> \\brief Appends val in vec if not already present !> \\date 05 2020 !*********************************************************************** real ( cdp ), allocatable , intent ( inout ) :: vec (:) real ( cdp ), intent ( in ) :: val vec = [ vec , val ] end subroutine append_real64 subroutine print_matrix ( a , m , n ) !! Our amazing subroutine to say hello (FORD) !-----print_matrix----------------------------------- ! !  print the matrix A with dimensions to the console m,n ! !---------------------------------------------------- !! Who to say hello to integer ( cint ), intent ( in ) :: n integer ( cint ), intent ( in ) :: m real ( cdp ), intent ( in ) :: a ( m , n ) integer ( cint ) :: i , j print * , '' do i = 1 , m print * , ( a ( i , j ), j = 1 , n ) end do print * , '' end subroutine print_matrix subroutine print_column_vector ( a , m ) !-----print_column_vector----------------------------------- ! !  Subroutine to print out an array of dimension m,n ! !---------------------------------------------------- integer ( cint ), intent ( in ) :: m real ( cdp ), intent ( in ) :: a ( m ) integer ( cint ) :: i print * , '' do i = 1 , m print * , a ( i ) end do print * , '' end subroutine print_column_vector function read_matrix_from_json ( object , path ) result ( imat ) Character ( * ), intent ( in ) :: object Character ( * ), intent ( in ) :: path type ( json_file ) :: json real ( cdp ), allocatable :: ivec (:) real ( cdp ), allocatable :: imat (:,:) integer ( cint ) :: i , n_cols , n_rows , var_type logical :: found type ( json_value ), pointer :: matrix_to_read , child type ( json_core ) :: core !load the file and print it to console: call json % load_file ( path ) if ( json % failed ()) error stop 'error loading file' !get number of rows and columns !assuming data stored by column !assuming each column has the same number of elements, !and is the same data type (integer(cint) in this case): call json % info ( object , found , var_type , n_cols ) if (. not . found ) error stop 'error: matrix_to_read not found' call json % info ( object // '(1)' , found , var_type , n_rows ) if (. not . found ) error stop \"object(1) not found\" !get a pointer to the wind matrix: call json % get ( object , matrix_to_read ) if (. not . associated ( matrix_to_read )) error stop 'error: matrix_to_read not found' !size the array: allocate ( imat ( n_rows , n_cols )) !grab each column of the matrix_to_read: ! [we need a json_core for this so we can use json_value_get_by_index] do i = 1 , n_cols call core % get_child ( matrix_to_read , i , child ) if (. not . associated ( child )) error stop 'error: column not found' call core % get ( child , ivec ) !get the vector of integer(cint)s (column of the matrix) if (. not . allocated ( ivec )) error stop 'error: could not get integer(cint) column' if ( size ( ivec ) /= n_rows ) error stop 'error: column is wrong size' imat (:, i ) = ivec deallocate ( ivec ) nullify ( child ) end do nullify ( matrix_to_read ) imat = transpose ( imat ) call json % destroy () end function read_matrix_from_json subroutine read_data_from_json ( polygon_order , number_of_elements , dofs , number_of_nodes , shape_fct_type , path ) character ( len =* ), intent ( in ) :: path integer ( cint ), intent ( inout ) :: polygon_order integer ( cint ), intent ( inout ) :: number_of_elements integer ( cint ), intent ( inout ) :: dofs integer ( cint ), intent ( inout ) :: number_of_nodes character ( len = 60 ), intent ( out ) :: shape_fct_type type ( json_file ) :: json logical :: is_found call json % initialize () ! Load the file. call json % load_file ( path ); if ( json % failed ()) stop ! Read in the data. json_block : block !call json%get(\"t0\", t0, is_found); if (.not. is_found) exit json_block call json % get ( \"polyOrd\" , polygon_order , is_found ); if (. not . is_found ) exit json_block call json % get ( \"ielem\" , number_of_elements , is_found ); if (. not . is_found ) exit json_block call json % get ( \"dim\" , dofs , is_found ); if (. not . is_found ) exit json_block call json % get ( \"nodedim\" , number_of_nodes , is_found ); if (. not . is_found ) exit json_block !call json%get(\"shapeFct\", shape_fct_type, is_found); if (.not. is_found) exit json_block !call json%get(\"elementsM\", elementsM, is_found); if (.not. is_found) exit json_block end block json_block call json % destroy () end subroutine read_data_from_json subroutine chdir ( path , err ) use iso_c_binding character ( * ) :: path integer ( cint ), optional , intent ( out ) :: err integer ( cint ) :: loc_err loc_err = c_chdir ( path // c_null_char ) if ( present ( err )) err = loc_err end subroutine subroutine to_lower ( string ) character ( len =* ), intent ( inout ) :: string integer ( cint ) :: i do i = 1 , len_trim ( string ) if ( iachar ( string ( i : i )) >= iachar ( 'A' ) . and . iachar ( string ( i : i )) <= iachar ( 'Z' )) then string ( i : i ) = char ( iachar ( string ( i : i )) + 32 ) end if end do end subroutine to_lower subroutine check_working_environment () implicit none character ( len = 500 ) :: cwd character ( len = 10 ) :: last_nine character ( len = 10 ) :: check_dir = \"/sbfem/bin\" integer ( cint ) :: str_len , start_pos call get_environment_variable ( 'PWD' , cwd ) call to_lower ( cwd ) print * , \"The current working directory is: \" , trim ( cwd ) str_len = len_trim ( cwd ) ! Get length of string without trailing spaces start_pos = max ( str_len - 9 , 1 ) ! Calculate starting position of last three characters last_nine = cwd ( start_pos : str_len ) if ( check_dir == last_nine ) then print * , \"! You are in the currect working directory !\" else if ( \"tran/sbfem\" == last_nine ) then print * , \"! you are NOT in the currect working directory, but \" // & \"i changes it for you to /bin:\" call chdir ( \"./bin\" ) call execute_command_line ( \"pwd\" ) print * , \"\" ; else print * , \"! you are NOT in the currect working directory !\" end if print * , \"----------------------------------------------------------\" ; end subroutine check_working_environment end module helper_functions","tags":"","loc":"sourcefile/helper_functions.f90.html"},{"title":"plots.f90 – SBFEM","text":"Source Code module plots use iso_fortran_env use functional , only : arange use math , only : lagrange , lagrange_diff use helper_functions , only : point_table use sbfem_functions , only : r_hat , r use SbfemClass implicit none private public :: plot_shape_functions , plot_superElement contains subroutine plot_shape_functions ( poly_ord ) !*********************************************************************** !*********************************************************************** implicit none integer , intent ( in ) :: poly_ord ! polynominal order integer :: i , j real ( real64 ), allocatable :: xm (:) integer :: io ! output 1 integer :: grid_size = 1000 real ( real64 ), allocatable :: plot_data_points (:) real ( real64 ) :: lower_bound = - 1.0 ! lower bound for lagrange shape functions (standard: -1.0) real ( real64 ) :: upper_bound ! upper bound for lagrange shape functions (standard: 1.0) upper_bound = 1._real64 + 2._real64 / grid_size plot_data_points = arange ( lower_bound , upper_bound , 2._real64 / grid_size ) xm = point_table ( poly_ord ) ! (array of root points for lagrangian polynominals) !open file to store points for plotting open ( newunit = io , file = \"../plots/data/lagrangeShapeFct.dat\" , status = \"replace\" ) ! plot lagrange shape functions do i = 1 , grid_size + 1 write ( io , * ) plot_data_points ( i ), ( lagrange ( plot_data_points ( i ), j , xm ), j = 1 , size ( xm )) end do ! close file close ( io ) !open file to store points for plotting open ( newunit = io , file = \"../plots/data/lagrangeShapeFctDeriv.dat\" , status = \"replace\" ) ! plot lagrange shape functions do i = 1 , grid_size + 1 write ( io , * ) plot_data_points ( i ), ( lagrange_diff ( plot_data_points ( i ), j , xm ), j = 1 , size ( xm )) end do ! close file close ( io ) ! create plots ! ! make clean !call execute_command_line(\"( cd plots && sh display_plots.sh )\") end subroutine plot_shape_functions subroutine plot_superElement ( sE ) !*********************************************************************** !*********************************************************************** implicit none type ( superElement ), intent ( in ) :: sE integer :: i , j integer :: i_elem , i_nodes , u_bund integer , allocatable :: elem_shape (:), nodes_shape (:) integer :: io1 , io2 , io3 ! output 1 ! integer :: grid_size = 1000 ! real(real64), allocatable :: plot_data_points(:) ! real(real64) :: lower_bound = -1.0  ! lower bound for lagrange shape functions (standard: -1.0) ! real(real64) :: upper_bound         ! upper bound for lagrange shape functions (standard: 1.0) ! upper_bound = 1._real64 + 2._real64/grid_size ! plot_data_points = arange(lower_bound, upper_bound, 2._real64/grid_size) ! xm  = point_table(poly_ord)         ! (array of root points for lagrangian polynominals) elem_shape = shape ( sE % elements_M ) nodes_shape = shape ( sE % nodes ) i_elem = elem_shape ( 1 ) i_nodes = nodes_shape ( 1 ) u_bund = ubound ( sE % elements_M , dim = 2 ) ! open file to store points for plotting open ( newunit = io1 , file = \"../plots/data/polygon2.dat\" , status = \"replace\" ) open ( newunit = io2 , file = \"../plots/data/polygon.dat\" , status = \"replace\" ) open ( newunit = io3 , file = \"../plots/data/nodes.dat\" , status = \"replace\" ) ! plot polygon data do i = 1 , i_elem write ( io1 , * ) sE % elements_M ( i , 1 : 2 ) write ( io1 , * ) sE % elements_M ( i , u_bund - 1 : u_bund ) write ( io1 , * ) 0.0_real64 , 0.0_real64 write ( io1 , * ) sE % elements_M ( i , 1 : 2 ) write ( io1 , * ) \"\" write ( io1 , * ) \"\" write ( io2 , * ) sE % elements_M ( i , 1 : 2 ), sE % elements_M ( i , u_bund - 1 : u_bund ), & 0.0_real64 , 0.0_real64 end do do i = 1 , i_nodes write ( io3 , * ) sE % nodes ( i ,:) end do ! close file close ( io1 ) close ( io2 ) close ( io3 ) ! create plots !  make clean call execute_command_line ( \"sh ../plots/display_plots.sh\" ) end subroutine plot_superElement end module plots","tags":"","loc":"sourcefile/plots.f90.html"},{"title":"sbfem_functions.f90 – SBFEM","text":"Source Code module sbfem_functions !use iso_fortran_env use , intrinsic :: iso_c_binding , only : cdp => c_double , cint => c_int use functional , only : arange use helper_functions , only : point_table use math , only : lagrange , lagrange_diff implicit none private public :: n_vec_f , n_mat_f , r_hat , r , j_mat , j_hat_mat contains !! Computes the shape function vector or its derivative for a !! given polynomial order and evaluation point. function n_vec_f ( eta , poly_ord , deriv ) result ( n_vec ) !! Computes the shape function vector or its derivative for a !!given polynomial order and evaluation point. ! Arguments real ( cdp ), intent ( in ) :: eta !! The natural coordinate (real number) at which the shape function !! or its derivative is evaluated. integer ( cint ), intent ( in ) :: poly_ord !! The natural coordinate (real number) at which the shape function logical , intent ( in ) :: deriv !! A logical type which determines whether the shape function or its !! derivative is computed. If deriv is true, the derivative is computed. real ( cdp ) :: n_vec ( poly_ord + 1 ) !! The shape function vector or its derivative. real ( cdp ) :: val integer ( cint ) :: i real ( cdp ), allocatable :: xm (:) xm = point_table ( poly_ord ) do i = 1 , poly_ord + 1 if ( deriv . eqv . . false .) then val = lagrange ( eta , i , xm ) else val = lagrange_diff ( eta , i , xm ) end if n_vec ( i ) = val end do end function n_vec_f function n_mat_f ( eta , poly_ord , deriv ) result ( n_mat ) !! create the shape function Vector and Matrix N real ( cdp ), intent ( in ) :: eta integer ( cint ), intent ( in ) :: poly_ord logical , intent ( in ) :: deriv real ( cdp ) :: n_mat ( 2 , ( poly_ord + 1 ) * 2 ) real ( cdp ) :: val integer ( cint ) :: i , j ! loop variables real ( cdp ), allocatable :: xm (:) integer ( cint ), allocatable :: range_list (:) xm = point_table ( poly_ord ) range_list = arange ( 0 , poly_ord + 1 ) do i = 1 , ( poly_ord + 1 ) j = i + range_list ( i ) if ( deriv . eqv . . false .) then val = lagrange ( eta , i , xm ) else val = lagrange_diff ( eta , i , xm ) end if n_mat ( 1 , j ) = val n_mat ( 1 , j + 1 ) = 0._cdp n_mat ( 2 , j ) = 0._cdp n_mat ( 2 , j + 1 ) = val end do end function n_mat_f function r_hat ( xi , eta , poly_ord , coord_vec , centre ) result ( r_vec ) !! create the shape function Vector and Matrix N real ( cdp ), intent ( in ) :: xi real ( cdp ), intent ( in ) :: eta integer ( cint ), intent ( in ) :: poly_ord real ( cdp ), intent ( in ) :: coord_vec (:) real ( cdp ), optional , intent ( in ) :: centre ( 2 ) real ( cdp ) :: r_vec ( 2 ) real ( cdp ) :: cen ( 2 ) if ( present ( centre )) then cen = centre else cen = [ 0._cdp , 0._cdp ] endif r_vec = xi * matmul ( n_mat_f ( eta , poly_ord , . false .), coord_vec ) + cen end function r_hat function r ( eta , poly_ord , coord_vec , centre ) result ( r_vec ) !! create the shape function Vector and Matrix N real ( cdp ), intent ( in ) :: eta integer ( cint ), intent ( in ) :: poly_ord real ( cdp ), intent ( in ) :: coord_vec (:) real ( cdp ), optional , intent ( in ) :: centre ( 2 ) real ( cdp ) :: r_vec ( 2 ) real ( cdp ) :: cen ( 2 ) if ( present ( centre )) then cen = centre else cen = [ 0._cdp , 0._cdp ] endif r_vec = matmul ( n_mat_f ( eta , poly_ord , . false .), coord_vec ) + cen end function r function j_mat ( eta , coord_vec , poly_ord , shape_function_type , centre ) result ( j_matrix ) ! Arguments real ( cdp ), intent ( in ) :: eta real ( cdp ), intent ( in ), dimension ( 2 ) :: coord_vec integer ( cint ), intent ( in ) :: poly_ord character ( len = :), allocatable , intent ( in ) :: shape_function_type real ( cdp ), dimension ( 2 , 2 ) :: j_matrix real ( cdp ), intent ( in ), dimension ( 2 ) :: centre real ( cdp ), dimension ( 2 ) :: r_result real ( cdp ), dimension ( 2 ) :: shape_dN_result ! Call the r function r_result = r ( eta , poly_ord , coord_vec , centre ) ! Call the shape_dN function shape_dN_result = n_vec_f ( eta , poly_ord , . true .) ! Populate the matrix j_matrix ( 1 , 1 ) = r_result ( 1 ) j_matrix ( 1 , 2 ) = r_result ( 2 ) j_matrix ( 2 , 1 ) = dot_product ( shape_dN_result , coord_vec ) j_matrix ( 2 , 2 ) = dot_product ( shape_dN_result , coord_vec ) end function j_mat ! J_Hat Matrix function function j_hat_mat ( xi , eta , coord_vec , poly_ord , shape_function_type , centre ) result ( j_hat_matrix ) ! Arguments real ( cdp ), intent ( in ) :: xi , eta real ( cdp ), intent ( in ), dimension ( 2 ) :: coord_vec integer ( cint ), intent ( in ) :: poly_ord character ( len = :), allocatable , intent ( in ) :: shape_function_type real ( cdp ), dimension ( 2 , 2 ) :: j_hat_matrix real ( cdp ), intent ( in ), dimension ( 2 ) :: centre real ( cdp ), dimension ( 2 ) :: r_result real ( cdp ), dimension ( 2 ) :: shape_dN_result ! Call the r function r_result = r ( eta , poly_ord , coord_vec , centre ) ! Call the shape_dN function shape_dN_result = n_vec_f ( eta , poly_ord , . true .) ! Populate the matrix j_hat_matrix ( 1 , 1 ) = r_result ( 1 ) j_hat_matrix ( 1 , 2 ) = r_result ( 2 ) j_hat_matrix ( 2 , 1 ) = xi * dot_product ( shape_dN_result , coord_vec ) j_hat_matrix ( 2 , 2 ) = xi * dot_product ( shape_dN_result , coord_vec ) end function j_hat_mat !     def r_hat_c(xi, eta, poly_ord, coord_vec, centre=np.array([0, 0])): !     return xi * np.dot(shape_N(eta, poly_ord)[1], coord_vec) + centre ! def r_hat(xi, eta, coord_vec, poly_ord): !     return xi * np.dot(shape_N(eta, poly_ord)[1], coord_vec) ! def r_c(eta, poly_ord, coord_vec, shape_function_type, centre=np.array([0, 0])): !     if shape_function_type == \"standard shape functions\": !         return (r_hat_c(1, eta, coord_vec, poly_ord, centre) - centre) !     elif shape_function_type == \"hierarchical shape functions\": !         return (r_hat_c(1, eta, coord_vec, poly_ord, centre) - centre)  # JET TO IMPLEMENT !!!!! !     else: !         print(\"ERROR: No valid shape function type in FUNCTION  rc(eta,coord_vec,centre)\") !         return np.array([0, 0]) ! def r(eta, poly_ord, coord_vec, shape_function_type, centre=np.array([0, 0])): !     if shape_function_type == \"standard shape functions\": !         return r_hat(1, eta, coord_vec, poly_ord) !     elif shape_function_type == \"hierarchical shape functions\": !         return r_hat(1, eta, coord_vec, poly_ord)  # JET TO IMPLEMENT !!!!! !     else: !         print(\"ERROR: No valid shape function type in FUNCTION -r(eta,coord_vec)\") !         return np.array([0, 0]) end module sbfem_functions","tags":"","loc":"sourcefile/sbfem_functions.f90.html"}]}